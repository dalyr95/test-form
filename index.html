
<!doctype html>

<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">

        <script src="external/react.development.js"></script>
        <script src="external/react-dom.development.js"></script>
		<script src="external/babel.min.js"></script>
		<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.4.1/cropper.min.css" rel="stylesheet">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.4.1/cropper.min.js"></script>
		<!--
        <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
        <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
		-->
		<style>
			*,
			*::before,
			*::after {
				box-sizing: border-box;
			}

			html,
			body,
			#root {
				font-family: Arial;
				margin: 0 auto;
				padding: 0;
				max-width: 840px;
				width: 100%;
			}

			body {
				padding: 20px;
			}

			form > div {
				margin-bottom: 10px;
			}

			.form-error {
				background-color: rgba(255, 0, 0, 0.2);
				border-radius: 4px;
				border: 2px solid red;
				display: inline-block;
				padding: 4px;
			}
		</style>

	</head>

	<body>
		<div id="root"></div>

		<script>
			/**
			 * Simple object check.
			 * @param item
			 * @returns {boolean}
			 */
			function isObject(item) {
				return (item && typeof item === 'object' && !Array.isArray(item));
			}

			/**
			 * Deep merge two objects.
			 * @param target
			 * @param ...sources
			 */
			function mergeDeep(target, ...sources) {
				if (!sources.length) return target;
				const source = sources.shift();

				if (isObject(target) && isObject(source)) {
					for (const key in source) {
					if (isObject(source[key])) {
						if (!target[key]) Object.assign(target, { [key]: {} });
						mergeDeep(target[key], source[key]);
					} else {
						Object.assign(target, { [key]: source[key] });
					}
					}
				}

				return mergeDeep(target, ...sources);
			}

			function resolveModelPath(path='', obj=self, separator='.') {
				var properties = Array.isArray(path) ? path : path.split(separator);
				if (properties[0] === 'fieldset') { properties.shift(); }
				return properties.reduce((prev, curr) => prev && prev[curr], obj)
			}
		</script>

		<script type="text/babel">
            class Page extends React.Component {
                constructor(props) {
					super(props);
				}

				render() {
					return (
						<Form>	
							<h4>Movie</h4>
							<p>Describe your movie</p>
							<div>
								<label htmlFor="title">Title</label>
								<input type="text" id="title" name="movie.title" onChange={(e => {
									if (e.currentTarget.value === 'hello') {
										e.currentTarget.value = 'world';
									}
								})}/>
							</div>
							
							<div>
								<label htmlFor="star">Star</label>
								<input type="text" id="star" name="movie.star" />
								<Error validate={(value) => {
									return value === 'scarjo'
								}}>
									<span>
										<img src="https://pa1.narvii.com/6658/6a551ca46768479feb8c1317e33a821667c912bd_128.gif" style={{height: '20px', float: 'left', marginRight: '6px'}}/>
										You know the answer is `scarjo`
									</span>
								</Error>
							</div>
							
							<div>
								<h4>Validate on blur</h4>
								<label htmlFor="year">Year</label>
								<input type="number" id="year" name="movie.year"/>
								
								<label htmlFor="genre">Genre</label>
								<input type="text" id="genre" name="movie.genre" pattern="[0-9]*"/>
							</div>
							
							<div>
								<label htmlFor="crap">Crap</label>
								<input type="checkbox" id="crap" checked name="crap" value="poo" />
							</div>

							<div>
								<Error
									name="scarjo"
									validate={(value) => {
										return (value.length === 0 || value === 'beer');
									}}
								>
									<div>You know the answer is `beer`</div>
								</Error>
								<hr/>
								<textarea name="scarjo" placeholder="I need a beer"></textarea>
							</div>
							
							<input type="email" required id="star" name="movie.email" />

							<Fieldset name="movie.categories">
								<div>
									<label htmlFor="movie.categories.1">Categories</label>
									<input type="text" id="movie.categories.1" name="movie.categories.1" />
									
									<label htmlFor="movie.categories.2">Categories</label>
									<input type="text" id="movie.categories.2" name="movie.categories.2"/>
								</div>
							</Fieldset>
						</Form>
					);
				}
			}
		</script>

		<script type="text/babel">
			class Form extends React.Component {
				constructor(props) {
					super(props);
					window.a = this;
					this.$form = React.createRef();

					this.onBlur = this.onBlur.bind(this);
					this.onChange = this.onChange.bind(this);
					this.onFocus = this.onFocus.bind(this);
					this.onSubmit = this.onSubmit.bind(this);

					this._ParseDom = this._ParseDom.bind(this);
					this._getDOMAttributes = this._getDOMAttributes.bind(this);
					this._getReactProps = this._getReactProps.bind(this);
					//
					this.updateModel = this.updateModel.bind(this);
					this.onUpdate = this.onUpdate.bind(this);

					this._initial = true;

					this._DOM = {};
					this._ReactDOM = {};

					this._formElementTypes = [
						'button',
						'datalist',
						'fieldset',
						'form',
						'input',
						'keygen',
						'label',
						'legend',
						'meter',
						'optgroup',
						'option',
						'output',
						'progress',
						'select',
						'textarea'
					];

					this.state = {};

					/**
					 * TODO - Find a way to replace this.state._ReactDOM || this._ReactDOM;
					 */
				}

				_ParseDom() {
					let $form = this.$form.current;
					let $elements = [...$form.elements];

					$elements.forEach($el => {
						let attributes = this._getDOMAttributes($el);
						this._DOM = this.updateModel(attributes['name'], attributes, this._DOM);
					});
				}

				_getDOMAttributes($el) {
					let attributes = {};
					let attrs = $el.attributes;
					for(var i = attrs.length - 1; i >= 0; i--) {
						attributes[attrs[i].name] = attrs[i].value;
					}

					attributes['checked'] = $el.checked;
					attributes['value'] = $el.value;

					return attributes;
				}

				_getReactProps($el) {
					if (this._formElementTypes.includes($el.type)) {
						let attributes = {
							checked: false,
							type: $el.type,
							value: '',
							...$el.props
						}

						return attributes;
					}
				}

				_parseDOMAttributesToReactProps(dom) {
					/**
					 * `required` attribute comes back as `required === ''`
					 */
					dom.required = (dom.required != null) ? true : dom.required;
					return dom;
				}

				componentDidMount() {
					this._initial = false;
				}

				onBlur(e) {
					console.log('onBlur', e.target.name);
					this.setState({
						$focused: null
					});
				}

				onFocus(e) {
					console.log('onFocus', e.target.name);
					this.setState({
						$focused: e.target
					});
				}

				onChange(e) {
					//this._DOM = this.updateModel(e.target.name, this._getDOMAttributes(e.target), this._DOM);

					let DOMAttributes = this._parseDOMAttributesToReactProps(this._getDOMAttributes(e.target));
					DOMAttributes.valid = e.target.checkValidity();

					this._ReactDOM = this.updateModel(e.target.name, mergeDeep(resolveModelPath(e.target.name, this.state._ReactDOM || this._ReactDOM), DOMAttributes), this.state._ReactDOM || this._ReactDOM);
					this.setState({
						_ReactDOM: this._ReactDOM
					}, () => this.onUpdate());
				}

				onSubmit(e) {
					console.log('onSubmit');
					e.preventDefault();
				}

				onUpdate() {
					let model = JSON.parse(JSON.stringify(this.state._ReactDOM));
					/*
					Object.entries(this.state.fieldSetModel).forEach(m => {
						let values = Object.values(resolveModelPath(`${m[0]}.${m[1]}`, apiModel));
						values = values.filter(v => v);
						this.updateModel(`${m[0]}.${m[1]}`, values, apiModel);
					});
					*/
					/*
					function process(obj) {
						console.log(arguments);
					}

					function traverse(o,func) {
						for (var i in o) {
							if (o[i] !== null && typeof(o[i])=="object") {
								//going one step down in the object tree!!
								traverse(o[i],func);
							} else {
								func.apply(this,[i,o[i]]);
							}
						}
					}

					//that's all... no magic, no bloated framework
					traverse(model,process);
					*/
					console.log('Sending to API =>', this.state._ReactDOM);
				}

				reportValidity(e) {
					console.log('reportValidity');
				}

				updateModel(path='', value, obj={}, separator='.') {
					//obj = JSON.parse(JSON.stringify(obj));

					var properties = Array.isArray(path) ? path : path.split(separator);

					properties.reduce((prev, curr, i) => {
						if (!prev[curr]) { prev[curr] = {}; }
						if (i === properties.length - 1) { prev[curr] = value; }
						return prev && prev[curr];
					}, obj);

					return obj;
				}

				render() {
					let renderWrappedChildren = (children, mergeParentProps) => {
						// Traverse through all children with pretty functional way :-)
						return React.Children.map(children, (child, i) => {
							// This is support for non-node elements (eg. pure text), they have no props
							if (!child.props) {
								return child;
							}

							if (child.type === Error) {
								let a = resolveModelPath(child.props.name || children[i - 1].props.name, this.state._ReactDOM || this._ReactDOM);
								if (!a) {
									if (!this._initial) {
										console.warn(`Surpress warning on load. Could not find an matching input for \`Error\` Component ${child.props.name || children[i - 1].props.name}`);
									}
									return null;
								}

								return React.cloneElement(child, {
									children: renderWrappedChildren(child.props.children),
									input: resolveModelPath(child.props.name || children[i - 1].props.name, this.state._ReactDOM || this._ReactDOM)
								});
							}

							// If current component has additional children, traverse through them as well!
							if (child.props.children) {
								// You have to override also children here
								let parentProps = mergeParentProps;

								if (child.type === Fieldset) {
									parentProps = Object.assign(mergeParentProps || {}, {
										fieldset: child.props.name
									});
								}

								return React.cloneElement(child, {
									children: renderWrappedChildren(child.props.children, parentProps),
								})
							}

							let _ReactProps = resolveModelPath(child.props.name, this.state._ReactDOM || this._ReactDOM);
							
							/**
							 * Populate on initial render
							 */
							if (!_ReactProps && this._formElementTypes.includes(child.type)) {
								_ReactProps = this._getReactProps(child);
								_ReactProps = Object.assign({}, mergeParentProps, _ReactProps);

								this.updateModel(child.props.name, _ReactProps, this.state._ReactDOM || this._ReactDOM);
							}

							if (_ReactProps && _ReactProps.valid === false) {
								console.warn('HTML failed validation. Need to do something about this');
							}

							// Return new component with overridden `onChange` callback
							return React.cloneElement(child, {
								onChange: () => {
									console.log('stop React from moaning');
								},
								...child.props,
								..._ReactProps,
								valid: null
							});
						});
					}

					return (
						<form
							ref={this.$form}
							{...this.props}
							onChange={this.onChange}
							onFocus={this.onFocus}
							onBlur={this.onBlur}
							onSubmit={this.onSubmit}
							//onInvalid={this.onChange}
						>
							{
								(this.props.children) ? renderWrappedChildren(this.props.children) : (null)
							}
						</form>
					);
				}
			}

			Form.defaultProps = { value: '' };
		</script>

		<script type="text/babel">
			class Fieldset extends React.Component {
				constructor(props) {
					super(props);

					this.$fieldset = React.createRef();

					this.state = {
						serialization: this.props.serialization || 'object',
						value: (this.props.serialization === 'array') ? '[]' : '{}'
					}
				}

				render() {
					return (
						<fieldset
							ref={this.$fieldset}
							name={this.props.name}
							{...this.props}
						>
						{
								React.Children.map(this.props.children, (child) => {
									return React.cloneElement(child, {
										key: `${this.props.name}-${child.props.name}`,
										fieldset: this.props.name
									});
								})
							}
							</fieldset>
					);
				}
			}
		</script>
		<script type="text/babel">
			class Error extends React.Component {
				constructor(props) {
					super(props);
				}

				render() {
					let show, valid;

					if (typeof this.props.validate !== 'function') { console.warn(`Provide a validate function for "${this.props.input.name}" with value "${this.props.input.value}"`); }
					if (this.props.input.value == null) { console.warn(`Provide a valid value for "${this.props.input.name}"`); }
					
					try {
						valid = this.props.validate(this.props.input.value);
					} catch(e) {
						console.error(e);

						return (null);
					}

					if (typeof valid !== 'boolean') {
						console.warn(`Provide \`<Error/>\` component for "${this.props.input.name}" with value "${this.props.input.value}", a validation function which returns a boolean.`);
					}

					show = (this.props.validate(this.props.input.value) === false) ? (
						<div className='form-error'>{this.props.message || this.props.children}</div>
					) : (null);

					return show;
				}
			}
		</script>
		<script type="text/babel">
			ReactDOM.render(<Page />, document.getElementById("root"));
		</script>
	</body>
</html>