
<!doctype html>

<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">

        <script src="external/react.development.js"></script>
        <script src="external/react-dom.development.js"></script>
		<script src="external/babel.min.js"></script>
		<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.4.1/cropper.min.css" rel="stylesheet">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.4.1/cropper.min.js"></script>
		<!--
        <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
        <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
		-->
		<style>
			*,
			*::before,
			*::after {
				box-sizing: border-box;
			}

			html,
			body,
			#root {
				font-family: Arial;
				margin: 0 auto;
				padding: 0;
				max-width: 840px;
				width: 100%;
			}

			body {
				padding: 20px;
			}
		</style>

	</head>

	<body>
		<div id="root"></div>

		<script>
			/**
			 * Simple object check.
			 * @param item
			 * @returns {boolean}
			 */
			function isObject(item) {
				return (item && typeof item === 'object' && !Array.isArray(item));
			}

			/**
			 * Deep merge two objects.
			 * @param target
			 * @param ...sources
			 */
			function mergeDeep(target, ...sources) {
				if (!sources.length) return target;
				const source = sources.shift();

				if (isObject(target) && isObject(source)) {
					for (const key in source) {
					if (isObject(source[key])) {
						if (!target[key]) Object.assign(target, { [key]: {} });
						mergeDeep(target[key], source[key]);
					} else {
						Object.assign(target, { [key]: source[key] });
					}
					}
				}

				return mergeDeep(target, ...sources);
			}

			function resolveModelPath(path='', obj=self, separator='.') {
				var properties = Array.isArray(path) ? path : path.split(separator);
				if (properties[0] === 'fieldset') { properties.shift(); }
				return properties.reduce((prev, curr) => prev && prev[curr], obj)
			}
		</script>

		<script type="text/babel">
            class Page extends React.Component {
                constructor(props) {
					super(props);
				}

				render() {
					return (
						<Form>	
							<h4>Movie</h4>
							<p>Describe your movie</p>
							<label htmlFor="title">Title</label><input type="text" id="title" name="movie.title" onChange={(e => {
								e.currentTarget.value = e.target.value + '123';
							})}/>

							<label htmlFor="star">Star</label><input type="text" id="star" name="movie.star" />
							<Error validate={(value) => {
								console.log(124, value);
								return value === 'scarjo'
							}}>
								<div>You know the answer is `scarjo`</div>
							</Error>

							<label htmlFor="year">Year</label><input type="number" id="year" name="movie.year" />
							<label htmlFor="genre">Genre</label><input type="text" id="genre" name="movie.genre" pattern="[0-9]*"/>

							<label htmlFor="crap">Crap</label><input type="checkbox" id="crap" checked name="crap" value="poo" />
							
							<div>
								<Error
									name="scarjo"
									validate={(value) => {
										return (value.length === 0 || value === 'beer')
									}}
								>
									<div>You know the answer is `beer`</div>
								</Error>
								<hr/>
								<textarea name="scarjo"></textarea>
							</div>
							
							<input type="email" required id="star" name="movie.email" />
						</Form>
					);
				}
			}
		</script>

		<script type="text/babel">
			class Form extends React.Component {
				constructor(props) {
					super(props);
					window.a = this;
					this.$form = React.createRef();

					this.onBlur = this.onBlur.bind(this);
					this.onChange = this.onChange.bind(this);
					this.onFocus = this.onFocus.bind(this);
					this.onSubmit = this.onSubmit.bind(this);

					this._ParseDom = this._ParseDom.bind(this);
					this._getDOMAttributes = this._getDOMAttributes.bind(this);
					this._getReactProps = this._getReactProps.bind(this);
					//
					this.updateModel = this.updateModel.bind(this);
					this.onUpdate = this.onUpdate.bind(this);

					this._DOM = {};
					this._ReactDOM = {};

					this._formElementTypes = [
						'button',
						'datalist',
						'fieldset',
						'form',
						'input',
						'keygen',
						'label',
						'legend',
						'meter',
						'optgroup',
						'option',
						'output',
						'progress',
						'select',
						'textarea'
					];

					this.state = {};

					/**
					 * TODO - Find a way to replace this.state._ReactDOM || this._ReactDOM;
					 */
				}

				_ParseDom() {
					let $form = this.$form.current;
					let $elements = [...$form.elements];

					$elements.forEach($el => {
						let attributes = this._getDOMAttributes($el);
						this._DOM = this.updateModel(attributes['name'], attributes, this._DOM);
					});
				}

				_getDOMAttributes($el) {
					let attributes = {};
					let attrs = $el.attributes;
					for(var i = attrs.length - 1; i >= 0; i--) {
						attributes[attrs[i].name] = attrs[i].value;
					}

					attributes['checked'] = $el.checked;
					attributes['value'] = $el.value;

					return attributes;
				}

				_getReactProps($el) {
					if (this._formElementTypes.includes($el.type)) {
						let attributes = {
							checked: false,
							type: $el.type,
							value: '',
							...$el.props
						}

						return attributes;
					}
				}

				_parseDOMAttributesToReactProps(dom) {
					/**
					 * `required` attribute comes back as `required === ''`
					 */
					dom.required = (dom.required != null) ? true : dom.required;
					return dom;
				}

				componentDidMount() {
					/*
					this._ParseDom();

					this.setState({
						_DOM: this._DOM
					})
					*/
				}

				onBlur(e) {
					//console.log('onBlur');
				}

				onChange(e) {
					//this._DOM = this.updateModel(e.target.name, this._getDOMAttributes(e.target), this._DOM);

					let DOMAttributes = this._parseDOMAttributesToReactProps(this._getDOMAttributes(e.target));
					DOMAttributes.valid = e.target.checkValidity();
					console.log(444, mergeDeep(resolveModelPath(e.target.name, this.state._ReactDOM || this._ReactDOM), DOMAttributes));
					this._ReactDOM = this.updateModel(e.target.name, mergeDeep(resolveModelPath(e.target.name, this.state._ReactDOM || this._ReactDOM), DOMAttributes), this.state._ReactDOM || this._ReactDOM);
					this.setState({
						_ReactDOM: this._ReactDOM
					});
				}

				onFocus(e) {
					//console.log('onFocus');
				}

				onSubmit(e) {
					console.log('onSubmit');
					e.preventDefault();
				}

				onUpdate() {
					let apiModel = JSON.parse(JSON.stringify(this.state.model));

					Object.entries(this.state.fieldSetModel).forEach(m => {
						let values = Object.values(resolveModelPath(`${m[0]}.${m[1]}`, apiModel));
						values = values.filter(v => v);
						this.updateModel(`${m[0]}.${m[1]}`, values, apiModel);
					});
					console.log('Sending to API =>', apiModel);
				}

				reportValidity(e) {
					console.log('reportValidity');
				}

				updateModel(path='', value, obj={}, separator='.') {
					//obj = JSON.parse(JSON.stringify(obj));

					var properties = Array.isArray(path) ? path : path.split(separator);

					properties.reduce((prev, curr, i) => {
						if (!prev[curr]) { prev[curr] = {}; }
						if (i === properties.length - 1) { prev[curr] = value; }
						return prev && prev[curr];
					}, obj);

					return obj;
				}

				render() {
					let renderWrappedChildren = (children) => {
						// Traverse through all children with pretty functional way :-)
						return React.Children.map(children, (child, i) => {
							// This is support for non-node elements (eg. pure text), they have no props
							if (!child.props) {
								return child;
							}
							
							if (child.type === Error) {
								let a = resolveModelPath(child.props.name || children[i - 1].props.name, this.state._ReactDOM || this._ReactDOM);
								if (!a) {
									console.warn(`Surpress warning on load. Could not find an matching input for \`Error\` Component ${child.props.name || children[i - 1].props.name}`);
									return null;
								}

								return React.cloneElement(child, {
									children: renderWrappedChildren(child.props.children),
									input: resolveModelPath(child.props.name || children[i - 1].props.name, this.state._ReactDOM || this._ReactDOM)
								});
							}

							// If current component has additional children, traverse through them as well!
							if (child.props.children) {
								// You have to override also children here
								return React.cloneElement(child, {
									children: renderWrappedChildren(child.props.children),
								})
							}

							let _ReactProps = resolveModelPath(child.props.name, this.state._ReactDOM || this._ReactDOM);

							if (!_ReactProps) {
								_ReactProps = this._getReactProps(child);
								this.updateModel(child.props.name, _ReactProps, this.state._ReactDOM || this._ReactDOM);
							}

							if (_ReactProps && _ReactProps.valid === false) {
								console.warn('Need to do something about this');
							}

							// Return new component with overridden `onChange` callback
							return React.cloneElement(child, {
								onChange: () => {
									console.log('stop React from moaning');
								},
								...child.props,
								//..._ReactProps,
								valid: null
							});
						});
					}

					return (
						<form
							ref={this.$form}
							{...this.props}
							onChange={this.onChange}
							onSubmit={this.onSubmit}
							//onInvalid={this.onChange}
						>
							{
								(this.props.children) ? renderWrappedChildren(this.props.children) : (null)
							}
						</form>
					);
				}
			}

			Form.defaultProps = { value: '' };
		</script>

		<script type="text/babel">
			class Fieldset extends React.Component {
				constructor(props) {
					super(props);

					this.$fieldset = React.createRef();
					this.$hidden = React.createRef();

					this.onChange = this.onChange.bind(this);

					this.state = {
						serialization: this.props.serialization || 'object',
						value: (this.props.serialization === 'array') ? '[]' : '{}'
					}
				}

				render() {
					return (
						<React.Fragment>
							<fieldset
								ref={this.$fieldset}
								name={this.props.name}
								{...this.props}
							>
							{
								React.Children.map(this.props.children, (child) => {
									return React.cloneElement(c, {
										key: `${this.props.name}-${child.props.name}`,
										fieldset: this.props.name
									});
								})
							}
							</fieldset>
						</React.Fragment>
					);
				}
			}
		</script>
		<script type="text/babel">
			class Error extends React.Component {
				constructor(props) {
					super(props);
				}

				render() {
					let show;
					console.log(9999, this.props, this.props.input.value);
					if (typeof this.props.validate !== 'function') { console.warn(`Provide a validate function for "${this.props.input.name}" with value "${this.props.input.value}"`); }

					show = (this.props.validate(this.props.input.value) === false) ? (
						<span className='form-error'>111{this.props.message || this.props.children}</span>
					) : (null);

					return show;
				}
			}
		</script>
		<script type="text/babel">
			ReactDOM.render(<Page />, document.getElementById("root"));
		</script>
	</body>
</html>